\label[ros]
\chap Robot Operating System

The Robot Operating System (or ROS) is “an open-source, meta-operating system”~\cite[ros1_intro]
that consists of “tools, libraries, and conventions that aim to simplify the task of creating complex and
robust robot applications across a wide variety of robotic platforms“~\cite[ros2_foxy_root].

A typical ROS application is composed of loosely coupled processes – nodes – (potentially distributed across
machines) that communicate with each other and work together to accomplish a certain goal (for example,
autonomous vehicle control). Each node can perform only a specific limited set of functions (e.g.: one node
can read data from LIDAR, another node can implement an obstacle detection algorithm from the LIDAR data and
another node can use the detected obstacles to plan the trajectory, etc.).

Such architecture greatly supports the separations of concerns and allows code reuse. That further enables
efficient code sharing of common functional among different projects with different applications. That in
fact, is one of the most significant features of ROS as there are thousands of ROS packages provided by the
ROS community. Then, developers can focus on their application specific problems while reusing the code for
the common parts.


\sec ROS Computation Graph

At runtime, ROS nodes and their communication interactions form so called “ROS Computation
Graph”~\cite[ros1_concepts]. The nodes are represented by the graph's vertices, while the edges
depicts the communication interactions.

(TODO: computation graph image)


ROS provides several {\em communication primitives} that can be used by nodes:
\begitems \style n
* {\sbf messages and topics} – publish/subscribe \nl
Nodes (publishers) can publish messages to a named topic. Other nodes (subscribers) can subscribe to a
topic and receive the published messages.

* {\sbf services} – synchronous RPC (Remote Procedure Call) (server/client) \nl
Nodes (service servers) can provide services. A service has a name. Other nodes (service clients) can
invoke/call a service and synchronously get a result.

* {\sbf actions} – asynchronous preemptible RPC with continuous feedback (server/client) \nl
Node (action servers) can provide actions. An action is preemptible task that has a goal, can provide
continuous feedback and returns a result if it is not cancelled. Other nodes (action clients) can invoke an
action (request a goal and subscribe for its feedback and result).

\enditems

The communication is strongly typed and ROS provides an interface description language (IDL) for describing
message types (used for pub/sub), service types and action types.


\sec ROS Common Concepts

\sec ROS 1

TODO

\secc Architecture

TODO

\secc Build System

TODO

\secc CLI

TODO

\secc Launch System

TODO

\sec ROS 2

\secc Architecture

\secc Build System

\secc CLI

\secc Launch System

\sec Summary of Differences between ROS 1 and ROS 2

ROS~2 has better architecture and offers more features. Thanks to DDS, it offers fine-grained QoS. It supports
reliable communication in non-ideal networks. Furthermore, the ROS 2 client libraries offer better control
over code execution and threading as they support writing custom executors. ROS 2 architecture is designed with
real-time support in mind (TODO: footnote)

The following table summarizes the most notable differences between ROS 1 and ROS 2:

\midinsert
\clabel[ros-comparison]{Summary of Differences between ROS 1 and ROS 2}
\ctable{lll}{
	Feature & ROS 1 Kinetic Kame & ROS 2 Foxy Fitzroy \crl \tskip4pt
	Supported Platforms
	& only Ubuntu officially supported (TODO: footnote)
	& Ubuntu, macOS, Windows (TODO: footnote) officially supported
	\cr
	Main Client Libraries
	& roscpp (C++), rospy (Python)
	& rclcpp (C++), rclpy (Python)
	\cr
	C++
	& C++03
	& C++14
	\cr
	Python
	& Python 2
	& Python 3
	\cr
	Real-Time Support
	& no
	& yes
	\cr
	Runtime Node Composition
	& no (TODO: Nodelets)
	& Composable Nodes
	\cr
	Parameters
	& global Parameter Server
	& parameters per node (no global Parameter Server), out-of-the-box “dynamic_reconfigure”-like features
	\cr
	Launch System
	& XML-based
	& Python-based
	\cr
	Transport
	& TCPROS or UDPROS
	& DDS (fine-grained QoS)
	\cr
	Communication Primitives
	& pub/sub, services, actions
	& pub/sub, services, actions
	\cr
	Threading Model
	& not much customizable
	& granular execution models, custom executors
	\cr
	Build
	& catkin + catkin_make/catkin_make_isolated
	& ament + colcon
	\cr
	Pure Python Packages
	& no
	& yes
	\cr
	Pure CMake Packages
	& no
	& yes
	\cr
	IDL
	& .msg/.srv
	& .msg/.srv/.action + extended features such as constraints
	\cr
}
\caption/t Summary of Differences between ROS 1 and ROS 2.
\endinsert
